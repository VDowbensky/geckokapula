/* SPDX-License-Identifier: MIT */
#include "em_timer.h"
#include "em_adc.h"
#include "em_cmu.h"
#include "em_gpio.h"
#include "em_opamp.h"
#include "em_vdac.h"
#include "InitDevice.h"

#include "rail.h"

#include "FreeRTOS.h"
#include "queue.h"

#include "dsp.h"
#include "dsp_driver.h"

#include <stdio.h>

/* Signal flow during reception
 * ----------------------------
 * Audio output is a PWM output driven by a timer.
 * I/Q input is read from the RAIL RX FIFO.
 * Audio output sample rate should have a known relationship
 * to the I/Q input sample rate.
 * To ensure the input and output streams keep synchronized, they
 * are driven by the same interrupt handler, which is the
 * RAIL RX FIFO event callback handler.
 * Every time a block of I/Q samples is received, one audio sample
 * is updated to the PWM value. Thus, the I/Q sample rate should
 * be an integer multiple of the audio sample rate.
 *
 * To avoid jitter and aliasing effects, the audio sample rate
 * should be synchronized to the PWM frequency, so that each
 * audio sample affects a constant number of PWM cycles.
 * Some attention should be paid to the effect of interrupt
 * timing jitter in updating the PWM value.
 * (This part is not done yet.)
 *
 * Software interfaces
 * -------------------
 * The callback handler interfaces to the fast DSP task
 * through a ring buffer and an RTOS queue.
 * Each queue item contains the number of samples to process
 * and pointers to input and output buffers.
 * The fast DSP task calls dsp_fast_rx with these buffers
 * to do the actual signal processing.
 * The fast DSP task can further defer processing to the
 * slow DSP task by buffering data and sending messages
 * using an RTOS queue.
 *
 * Signal flow during transmission
 * -------------------------------
 * Audio input comes from the integrated ADC.
 * Transmitted signal is generated by writing the channel register
 * of the frequency synthesizer, so a frequency modulated signal
 * is transmitted.
 * Both the audio input and frequency modulation output are
 * handled in the ADC interrupt handler, and they have the same
 * sampling rate.
 *
 */

/* -------------------------
 * Buffer size configuration
 * ------------------------- */

/* Ratio of I/Q input and audio output sample rates.
 * This determines the number of samples to read
 * at a time from the RAIL FIFO. */
#define RX_SAMPLE_RATIO 2

/* How many samples to process at a time in the DSP task.
 * This is the number of audio samples, so number of I/Q
 * samples is RX_SAMPLE_RATIO times the value. */
#define RX_DSP_BLOCK 32

/* Size of the RX ring buffer as a multiple of block size. */
#define RX_BUF_BLOCKS 2

/* How many transmit samples to process at a time */
#define TX_DSP_BLOCK 32

/* Size of the TX ring buffer as a multiple of block size. */
#define TX_BUF_BLOCKS 2


// TODO: move this in some common plane as it's also in railtask.c
#define MIDDLECHANNEL 32

/* ----------------------
 * Buffers and data types
 * ---------------------- */

/* Diagnostics, could be moved to some more global place */
struct diagnostics {
	uint32_t rx_blocks_overflow, rx_blocks_isr, rx_blocks_task;
	uint32_t rx_rail_underruns, rx_samples_isr;
	uint32_t tx_blocks_overflow, tx_blocks_isr, tx_blocks_task;

	// Cycle counters to estimate CPU usage of fast DSP
	uint32_t cycles_dsp, cycles_nodsp;

	// Estimate of CPU time used by fast DSP
	float dsp_cpu_use;
};
struct diagnostics diag;

/* DSP driver state */
struct dsp_driver {
	// I/Q input and audio output buffers current index
	unsigned rx_i;
	// Audio input and FM output buffers current index
	unsigned tx_i;
	// Audio output buffer
	audio_out_t audio_out[RX_DSP_BLOCK * RX_BUF_BLOCKS];
	// I/Q input buffer
	iq_in_t iq_in[RX_DSP_BLOCK * RX_BUF_BLOCKS * RX_SAMPLE_RATIO];
	// Audio input buffer
	audio_in_t audio_in[TX_DSP_BLOCK * TX_BUF_BLOCKS];
	// FM output buffer
	fm_out_t fm_out[TX_DSP_BLOCK * TX_BUF_BLOCKS];
};
struct dsp_driver dsp_driver;

/* Message sent from interrupt to fast DSP task during receive */
struct fast_dsp_rx_msg {
	iq_in_t *in;
	audio_out_t *out;
	uint16_t in_len, out_len;
};

/* Message sent from interrupt to fast DSP task during transmit */
struct fast_dsp_tx_msg {
	audio_in_t *in;
	fm_out_t *out;
	uint16_t len;
};

/* Queues to communicate between interrupts and fast DSP task */
QueueHandle_t fast_dsp_rx_q, fast_dsp_tx_q;
QueueSetHandle_t fast_dsp_qs;


/* ----------------
 * Driver functions
 * ---------------- */

/* rail_callback is called from a RAIL interrupt handler */
void rail_callback(RAIL_Handle_t rail, RAIL_Events_t events)
{
	BaseType_t yield = 0;
	struct dsp_driver *d = &dsp_driver;
	if (events & RAIL_EVENT_RX_FIFO_ALMOST_FULL) {
		unsigned nread, i = d->rx_i;

		uint32_t audio_out = d->audio_out[i];
		TIMER_CompareBufSet(TIMER0, 0, audio_out);
#ifdef USE_OPAMPS
		// DAC has more resolution than PWM so really bit depth
		// should be increased in DSP code, but for now just scale
		// it to use most of DAC range.
		VDAC_Channel1OutputSet(VDAC0, audio_out * 20);
#endif

		nread = RAIL_ReadRxFifo(rail, (uint8_t*)(d->iq_in + i * RX_SAMPLE_RATIO), sizeof(iq_in_t) * RX_SAMPLE_RATIO);
		if (nread != sizeof(iq_in_t) * RX_SAMPLE_RATIO)
			++diag.rx_rail_underruns;
		++diag.rx_samples_isr;

		if (i % RX_DSP_BLOCK == RX_DSP_BLOCK - 1) {
			// Index of the first sample in the latest received block
			unsigned fi = i - (RX_DSP_BLOCK - 1);

			struct fast_dsp_rx_msg msg = {
				d->iq_in + fi * RX_SAMPLE_RATIO,
				d->audio_out + fi,
				RX_DSP_BLOCK * RX_SAMPLE_RATIO,
				RX_DSP_BLOCK
			};
			if (xQueueSendFromISR(fast_dsp_rx_q, &msg, &yield))
				++diag.rx_blocks_isr;
			else
				++diag.rx_blocks_overflow;
		}

		if (++i >= RX_DSP_BLOCK * RX_BUF_BLOCKS)
			i = 0;
		d->rx_i = i;
	}
	portYIELD_FROM_ISR(yield);
}


/* Set frequency synthesizer channel */
static inline void synth_set_channel(uint32_t ch)
{
	*(uint32_t*)0x40083038 = ch;
}


/* ADC interrupt, used for transmission */
void WTIMER0_IRQHandler(void)
{
	BaseType_t yield = 0;
	struct dsp_driver *d = &dsp_driver;
	unsigned i = d->tx_i;
	synth_set_channel(d->fm_out[i]);
	// ADC data should be available by now if ADC was started
	// in the previous timer interrupt.
	d->audio_in[i] = ADC0->SINGLEDATA;
	ADC_Start(ADC0, adcStartSingle);

	if (i % TX_DSP_BLOCK == TX_DSP_BLOCK - 1) {
		// Index of the first sample in the block
		unsigned fi = i - (TX_DSP_BLOCK - 1);

		struct fast_dsp_tx_msg msg = {
			d->audio_in + fi,
			d->fm_out + fi,
			TX_DSP_BLOCK
		};
		if (xQueueSendFromISR(fast_dsp_tx_q, &msg, &yield))
			++diag.tx_blocks_isr;
		else
			++diag.tx_blocks_overflow;
	}

	if (++i >= TX_DSP_BLOCK * TX_BUF_BLOCKS)
		i = 0;
	d->tx_i = i;

	TIMER_IntClear(WTIMER0, TIMER_IF_CC0);
	portYIELD_FROM_ISR(yield);
}


int start_rx_dsp(RAIL_Handle_t rail)
{
	// TODO clear the audio buffer for first round
	unsigned r;
	TIMER_IntDisable(WTIMER0, TIMER_IF_CC0);
	RAIL_Idle(rail, RAIL_IDLE_ABORT, false);

#ifdef MIC_EN_PIN
	GPIO_PinOutClear(MIC_EN_PORT, MIC_EN_PIN);
#endif
#ifdef RX_EN_PIN
	GPIO_PinOutClear(TX_EN_PORT, TX_EN_PIN);
	GPIO_PinOutSet(RX_EN_PORT, RX_EN_PIN);
#endif
	RAIL_ResetFifo(rail, false, true);
	RAIL_SetRxFifoThreshold(rail, sizeof(iq_in_t) * RX_SAMPLE_RATIO);
	// Setting channel through RAIL does not always seem to work
	// after writing directly to the channel register,
	// so write the channel register too.
	synth_set_channel(MIDDLECHANNEL);
	r = RAIL_StartRx(rail, MIDDLECHANNEL, NULL);
	printf("RAIL_StartRx: %u\n", r);
	return r;
}


int start_tx_dsp(RAIL_Handle_t rail)
{
	(void)rail;
	// TODO clear the FM buffer for first round
#ifdef MIC_EN_PIN
	GPIO_PinOutSet(MIC_EN_PORT, MIC_EN_PIN);
#endif
#ifdef RX_EN_PIN
	GPIO_PinOutClear(RX_EN_PORT, RX_EN_PIN);
	GPIO_PinOutSet(TX_EN_PORT, TX_EN_PIN);
#endif
	RAIL_Idle(rail, RAIL_IDLE_ABORT, true);
	RAIL_StartTxStream(rail, MIDDLECHANNEL, RAIL_STREAM_CARRIER_WAVE);
	NVIC_EnableIRQ(WTIMER0_IRQn);
	TIMER_IntEnable(WTIMER0, TIMER_IF_CC0);
	ADC_Start(ADC0, adcStartSingle);
	return 0;
}



void setup_opamps(void)
{
#ifdef USE_OPAMPS
	// VDAC0 is used for both speaker and microphone.
	// Channel 0 biases microphone input opamp.
	// Channel 1 is audio output.
	CMU_ClockEnable(cmuClock_VDAC0, true);
	VDAC_Init(VDAC0, &(const VDAC_Init_TypeDef){
		.mainCalibration = true,
		.asyncClockMode = false,
		.warmupKeepOn = true,
		.refresh = vdacRefresh8,
		.prescaler = 0,
		.reference = vdacRef1V25Ln,
		.ch0ResetPre = false,
		.outEnablePRS = false,
		.sineEnable = false,
		.diff = false,
	});

	VDAC_Channel0OutputSet(VDAC0, 0x800);
	VDAC_Channel1OutputSet(VDAC0, 0x800);
	VDAC_Enable(VDAC0, 0, true);
	VDAC_Enable(VDAC0, 1, true);

	// Audio output
	OPAMP_Enable(VDAC0, OPA1, &(const OPAMP_Init_TypeDef){
		.negSel = opaNegSelResTap,
		.posSel = opaPosSelDac,
		.outMode =  opaOutModeMain, // PD14
		.resSel = opaResSelR2eqR1,
		.resInMux = opaResInMuxVss,
		.outPen = VDAC_OPA_OUT_MAINOUTEN,
		.drvStr = opaDrvStrHighAccHighStr, // maybe adjust later to optimize power consumption
		.gain3xEn = false,
		.halfDrvStr = false,
		.ugBwScale = false,
		.prsEn = false,
		.prsMode = opaPrsModeDefault,
		.prsSel = opaPrsSelDefault,
		.prsOutSel = opaPrsOutDefault,
		.aportYMasterDisable = false,
		.aportXMasterDisable = false,
		.settleTime = 3, // from OPA_INIT_INVERTING defaults
		.startupDly = 0,
		.hcmDisable = false,
		.defaultOffsetN = true,
		.offsetN = 0,
		.defaultOffsetP = true,
		.offsetP = 0,
	});

	// Microphone input
	OPAMP_Enable(VDAC0, OPA0, &(const OPAMP_Init_TypeDef){
		.negSel = opaNegSelResTap,
		.posSel = opaPosSelDac,
#if 0 // Opamp output on pin for measurements
		.outMode = opaOutModeAPORT1YCH19, // PF3
		.outPen = VDAC_OPA_OUT_APORTOUTSEL_APORT1YCH19,
#else
		.outMode = opaOutModeDisable,
		.outPen = 0,
#endif
		.resSel = opaResSelR2eqR1, // may be changed to adjust mic gain
		.resInMux = opaResInMuxNegPad,
		.drvStr = opaDrvStrHighAccHighStr, // maybe adjust later to optimize power consumption
		.gain3xEn = false,
		.halfDrvStr = false,
		.ugBwScale = false,
		.prsEn = false,
		.prsMode = opaPrsModeDefault,
		.prsSel = opaPrsSelDefault,
		.prsOutSel = opaPrsOutDefault,
		.aportYMasterDisable = false,
		.aportXMasterDisable = false,
		.settleTime = 3, // from OPA_INIT_INVERTING defaults
		.startupDly = 0,
		.hcmDisable = false,
		.defaultOffsetN = true,
		.offsetN = 0,
		.defaultOffsetP = true,
		.offsetP = 0,
	});
#endif
}


void setup_adc(void)
{
	CMU_ClockEnable(cmuClock_WTIMER0, true);
	CMU_ClockEnable(cmuClock_ADC0, true);

	// Use timer to make an accurate 24 kHz sample rate for ADC.
	// Maybe TIMER1 could be used instead of WTIMER0 if
	// encoder decoding would be done using PCNT instead of TIMER1.
	// This would lave WTIMER0 still free for other future use.
	TIMER_Init(WTIMER0, &(const TIMER_Init_TypeDef) {
		.enable = 1,
		.debugRun = 0,
		.prescale = timerPrescale64,
		.clkSel = timerClkSelHFPerClk,
		.count2x = 0,
		.ati = 0,
		.fallAction = timerInputActionNone,
		.riseAction = timerInputActionNone,
		.mode = timerModeUp,
		.dmaClrAct = 0,
		.quadModeX4 = 0,
		.oneShot = 0,
		.sync = 0,
	});
	TIMER_InitCC(WTIMER0, 0, &(const TIMER_InitCC_TypeDef) {
		.eventCtrl = timerEventRising,
		.edge = timerEdgeNone,
		.prsSel = timerPRSSELCh0,
		.cufoa = timerOutputActionNone,
		.cofoa = timerOutputActionNone,
		.cmoa = timerOutputActionNone,
		.mode = timerCCModeCompare,
		.filter = 0,
		.prsInput = 0,
		.coist  = 0,
		.outInvert = 0,
		.prsOutput = timerPrsOutputDefault,
	});
	// Cycle length is top value + 1
	TIMER_TopSet(WTIMER0, 24);
	TIMER_CompareSet(WTIMER0, 0, 0);
	// TODO: maybe enable it only during TX
	TIMER_Enable(WTIMER0, 1);

	ADC_Init(ADC0, &(const ADC_Init_TypeDef) {
		.ovsRateSel = adcOvsRateSel8,
		.warmUpMode = adcWarmupKeepADCWarm,
		.timebase = ADC_TimebaseCalc(0),
		.prescale = ADC_PrescaleCalc(4000000, 0),
		.tailgate = 0,
		.em2ClockConfig = adcEm2Disabled,
	});

	ADC_InitSingle(ADC0, &(const ADC_InitSingle_TypeDef) {
		.prsSel = adcPRSSELCh0,
		.acqTime = adcAcqTime4,
		.reference = adcRef1V25,
		.resolution = adcResOVS,
		.posSel = MIC_APORT,
		.negSel = adcNegSelVSS,
		.diff = 0,
		.prsEnable = 0,
		.leftAdjust = 1,
		.rep = 0,
		.singleDmaEm2Wu = 0,
		.fifoOverwrite = 0,
	});
}


// Initialize hardware used for signal I/O.
void dsp_hw_init(void)
{
	setup_adc();
	setup_opamps();
#ifdef SPK_EN_PIN
	// Make the speaker pin open drain since it is pulled up
	// to a voltage higher than EFR32 supply.
	GPIO_PinModeSet(SPK_EN_PORT, SPK_EN_PIN, gpioModeWiredAnd, 0);
#endif
}


/* Create the RTOS objects needed by DSP.
 * Called before starting the scheduler. */
void dsp_rtos_init(void)
{
	fast_dsp_rx_q = xQueueCreate(RX_BUF_BLOCKS - 1, sizeof(struct fast_dsp_rx_msg));
	fast_dsp_tx_q = xQueueCreate(TX_BUF_BLOCKS - 1, sizeof(struct fast_dsp_tx_msg));
	fast_dsp_qs = xQueueCreateSet(RX_BUF_BLOCKS - 1 + TX_BUF_BLOCKS - 1);
	xQueueAddToSet(fast_dsp_rx_q, fast_dsp_qs);
	xQueueAddToSet(fast_dsp_tx_q, fast_dsp_qs);
}


void fast_dsp_task(void *arg)
{
	(void)arg;
	uint32_t cyc1, cyc2;
	uint32_t cycles_dsp_prev = 0, cycles_nodsp_prev = 0;
	dsp_update_params();
	cyc2 = DWT->CYCCNT;
	for (;;) {
		QueueHandle_t q;
		q = xQueueSelectFromSet(fast_dsp_qs, portMAX_DELAY);
		cyc1 = DWT->CYCCNT;
		diag.cycles_nodsp += cyc1 - cyc2;
		if (q == fast_dsp_rx_q) {
			struct fast_dsp_rx_msg msg;
			if (xQueueReceive(q, &msg, 0)) {
				dsp_fast_rx(msg.in, msg.in_len, msg.out, msg.out_len);
				++diag.rx_blocks_task;
			}
		} else if (q == fast_dsp_tx_q) {
			struct fast_dsp_tx_msg msg;
			if (xQueueReceive(q, &msg, 0)) {
				dsp_fast_tx(msg.in, msg.out, msg.len);
				++diag.tx_blocks_task;
			}
		}
		cyc2 = DWT->CYCCNT;
		diag.cycles_dsp += cyc2 - cyc1;
		// Update estimate of CPU usage. This is more useful than
		// FreeRTOS run time counters and rtos-views for benchmarking
		// because this one handles wrapping counters properly
		// and updates results without having to stop the program.
		uint32_t diff_dsp   = diag.cycles_dsp   - cycles_dsp_prev;
		uint32_t diff_nodsp = diag.cycles_nodsp - cycles_nodsp_prev;
		if (diff_dsp + diff_nodsp >= 38400000UL) {
			diag.dsp_cpu_use = (float)diff_dsp / (float)(diff_dsp + diff_nodsp);
			cycles_dsp_prev = diag.cycles_dsp;
			cycles_nodsp_prev = diag.cycles_nodsp;
		}
	}
}
